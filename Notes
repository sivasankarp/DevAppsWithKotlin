API level 11 - fragment more dynamic and flexible UI on large screen size such as tablet
OS can only open activity
Activity inherit from Context class but fragment not so we have to use context property from fragment to have access to app 
data typically associated with the context such as string and image resource
ActivityCompat extends ContextCompat
open class Fragment : ComponentCallbacks
Fragment have same back stack as activity except that the entire stack contained in activity
Fragment contain arguments in the form of bundle which is key value store also known as dictionary or associative array data
structure
safe args is gradle plugin that gurantee both side match up while transferring data from fragment a and fragment b
Android allows us to navigate between activities both within your app and to activities provided by other applications for eg
we can launch system camera activity to capture photos or launch a contact app to choose from
Intent can be 
Explicit - use to launch an activity using the target activity class and mostly used to launch other activities within your app
navigation component do this for us when we navigate to other activities from naviagtion graph in our app
Implicit - Implicit intent provide abstract description of the operation to be performed and they often used to launch activities
that are exposed by other applications. each implicit intent must have an action e.g ACTION_VIEW, ACTION_DIAL, ACTION_EDIT
in addition to action implicit intent have category and datatypes to further describe the action e.g CATEGORY_APP_MUSIC, 
CATEGORY_APP_GALLERY, CATEGORY_APP_CALENDER also include data type MIME DATA TYPE like text or jpeg which allows to choose
app based on data they can accept
activities that are launched  explicitely can be only declared just with activity tag in manifest while implicit lanuch activity
require intent fiter, intent filter is used to expose that your activity can responsd to implicit intent with certain action
categoty and data type
val args = GameWonFragmentArgs.fromBundle(arguments)
   val shareIntent = Intent(Intent.ACTION_SEND)
        shareIntent.setType("text/plain")
            .putExtra(Intent.EXTRA_TEXT, getString(R.string.share_success_text, args.numCorrect, args.numQuestions))
   return shareIntent
}
implicit launch activity required intent filter while normal activity can declared with <activity> tag only
Intent extra is like key value data similar we use in fragment used to provide argument for intent some argument have predefined
key such as to add strin we have Intent.EXTRA_TEXT key
private fun getShareIntent() : Intent {
        val args = GameWonFragmentArgs.fromBundle(arguments!!)
        return ShareCompat.IntentBuilder.from(activity)
                .setText(getString(R.string.share_success_text, args.numCorrect, args.numQuestions))
                .setType("text/plain")
                .intent
  }
  if (null == getShareIntent().resolveActivity(activity!!.packageManager)) {
  //package manager knows about every activity that registered in manifest across every application
            // hide the menu item if it doesn't resolve
            menu?.findItem(R.id.share)?.setVisible(false)
  }
  ShareCompat fluent api to handle sharing
 Navigation listener in on create they called whenever destination changes 
  // prevent nav gesture if not on start destination
navController.addOnDestinationChangedListener { nc: NavController, nd: NavDestination, args: Bundle? ->
   if (nd.id == nc.graph.startDestination) {
       drawerLayout.setDrawerLockMode(DrawerLayout.LOCK_MODE_UNLOCKED)
   } else {
       drawerLayout.setDrawerLockMode(DrawerLayout.LOCK_MODE_LOCKED_CLOSED)
   }
}

Every activity or every fragment have lifecycle
        resumed
           |
        started
           |
        created
           |
 initialize  destroy
 why all this matter and what the use of lifecycle - to know all about this we can manage situtation like which resource to 
 available in background or to pause as we have to give smoth experience to user do program proactively which means clean
 unused resource and defensively in case os does something like restart
 
 MotionLayout is a library that lets you add rich motion into your Android app. It's based upon ConstraintLayout and lets you 
 animate anything that you can build using ConstraintLayout.
 
 Navigation Controller class manages navigation within our navigation host fragment
 navigation host fragment is the parent in our view hierarchy of current fragment it means we can traverse up this heirarchy 
 to find nav host fragment from any view in our fragment
 
Navigation.findNavController(view).navigate(R.id.action_titleFragment_to_gameFragment)

Kotlin Extension function allow a class to extend the functionality of an existing class without subclassing it KTX has an 
extension function for an android view class so with kotlin extension we can use 

view.findNavController().navigate(R.id.action_titleFragment_to_gameFragment)

Android application provide onscreen back button which handle back stack just like back button in android device


Terminating a process

Make sure you are using a device or emulator running at least API level 28. This is easier to set up for an emulator.
Make sure adb is installed. If not, see instructions below.
Make sure your app is in the background - this only happens when the app is in the background. You can do this by hitting 
the home button.
Run the command:
adb shell am kill com.example.android.dessertpusher
This will stop the process as-if it had been stopped by the Android operating system.
Adding ADB to your path
If you try running adb in a terminal and you see something similar to the message below, read on:
Command Line Interface showing "command not found" after typing adb
ADB (Android Debug Bridge) is command line tool, and if you want to use it from the command line, it needs to be part of 
your path. First you’ll find where the adb executable 
lives, then you’ll add that to your path.
1. Find the platform-tools folder which contains adb:
Adb is part of the Android SDK, which is downloaded as part of Android Studio. You can find the location of this SDK by 
going to Tools -> SDK Manager
ADB is located in this location, followed by platform-tools/ so in the example above, you could find adb in:
/Users/lmf/Library/Android/sdk/platform-tools/
2. Add adb to your path:
Adding a variable to your path varies by platform, follow the instructions below to add the platform-tools 
location you located above.
Windows
Go to Advanced system settings:
Windows 8 and 10: Search -> System (Control Panel) -> Advanced system settings
Windows 7: Right-click Computer -> Properties -> Advanced system settings
Windows Vista: Right click My Computer -> Properties -> Advanced system settings
Windows XP: Start -> Control Panel -> System -> Advanced tab
Click Environment Variables
Find the System Variables section and then look to see if you have a PATH environment variable:
If you find one, click Edit
If you do not find one, click New to add one
Add ;<Path to platform-tools> to the end of the Variable value box
Click OK on all windows to save
Ensure you can run adb by typing:
adb
You should see output, including something like:
text showing Android Debug Bridge version 1.0.40 Version 4986621
Mac/Linux
Adding a path variable is done using the terminal on Mac/Linux.
Open a Terminal
Create a .bash_profile file if you don’t have one already. This is a configuration file for bash) - it’s executed when you start bash:
touch ~/.bash_profile
Open up the ~/.bash_profile file in your preferred text editor:
open ~/.bash_profile
Add the following to your .bash_profile file and save:
export PATH=<Path to platform-tools>:$PATH
Either restart your terminal, or enter:
source ~/.bash_profile
Ensure you can run adb by typing:
adb
You should see output, including something like:
